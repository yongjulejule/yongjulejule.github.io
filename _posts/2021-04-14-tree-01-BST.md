---
layout: post
title: "Tree 01. BST(Binary Search Tree, ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬)"
comments: true
excerpt_separator: "<!--more-->"
categories: 
- Algorithms
tags:
- Algorithms
- MIT OCW
- tree
order: 1
date: '2021-04-14 10:47:00 +0900'
last_modified_at: '2021-04-16 10:56:00 +0900'
---


> _MIT introduction to Algorithm (6.006) Lecture 5ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤._

## Runway Reservation Problem

ê³µí•­ì—ì„œ ë¹„í–‰ê¸°ë“¤ì˜ ì°©ë¥™ ì˜ˆì • ì‹œê°„ì„ ìƒê°í•´ë³´ì.

ë¹„í–‰ê¸°ì—ì„œ ìš”ì²­í•œ ì˜ˆì • ì‹œê°„ì„ $$t$$ ë¼ í•˜ê³ , $$t$$ ë¡œë¶€í„° $$k$$ ì‹œê°„ ë‚´ì— ë‹¤ë¥¸ ì°©ë¥™ ìš”ì²­ì´ ì—†ë‹¤ë©´ $t$ ë¥¼ ì§‘í•© $R$ ì— ì¶”ê°€í•œë‹¤. ë§Œì•½ ë¹„í–‰ê¸°ê°€ ì°©ë¥™í•˜ê³  ë‚˜ë©´ $t$ ë¥¼ $R$ ì—ì„œ ì œì™¸í•œë‹¤.
<!--more-->
$R = {41, 46, 49, 56}~ and ~ k = 3$  ì´ë¼ë©´ ë‹¤ìŒê³¼ ê°™ì´ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë‹¤.

![Figure 1](https://github.com/yongjulejule/yongjulejule.github.io/blob/master/_posts/images/BST/algo-1%20(1).png?raw=true)

- ë§Œì•½, ìš”ì²­í•œ ì‹œê°„ $t$ê°€ 44ë¼ë©´, $46 \in R$ ì´ë¯€ë¡œ $R$ì— ì¶”ê°€í•  ìˆ˜ ì—†ë‹¤.
- $t=53$ ì´ë¼ë©´, ì¡°ê±´ì— ì¶©ì¡±í•˜ë¯€ë¡œ $R$ ì— ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
- $t=20$ ì´ë¼ë©´, ì´ë¯¸ ì§€ë‚œ ì‹œê°„ìœ¼ë¡œ ì¶”ê°€í•˜ì§€ ì•ŠëŠ”ë‹¤.

Goal: ì´ ì‹œìŠ¤í…œì„ íš¨ìœ¨ì ìœ¼ë¡œ ê°€ë™í•´ì„œ, $O(lgn)$ ë‚´ì— ì‹¤í–‰ë˜ê²Œ í•œë‹¤.

- Unsorted list / array 
  - ì‚½ì…ì€ $O(1)$ ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ì§€ë‹ˆì§€ë§Œ, $t$ê°€ ì í•©í•œ ì‹œê°„ì¸ì§€ ì²´í¬í•˜ëŠ”ë° $O(n)$ ì˜ ì‹œê°„ì´ ê±¸ë¦°ë‹¤.
- Sorted data
  - Array: ì˜¤ë¥˜ë¥¼ ì°¾ê¸° ìœ„í•´ Binary Searchë¥¼ ì‹œí–‰í•  ìˆ˜ ìˆë‹¤.
    - íƒìƒ‰í•˜ëŠ”ë° $O(lgn)$ ì˜ ì‹œê°„ì´ ê±¸ë¦¬ê³ , ë¹„êµí•˜ëŠ”ë° $O(1)$ ì˜ ì‹œê°„ì´ ê±¸ë¦°ë‹¤.
    - ì‚½ì…í•˜ê¸° ìœ„í•´ì„œëŠ”, ì •ë ¬ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ë‹¤ë¥¸ ë°ì´í„°ë¥¼ ì´ë™ì‹œì¼œì•¼ í•˜ë¯€ë¡œ $O(n)$ì˜ ì‹œê°„ì´ ê±¸ë¦°ë‹¤...!
  - Linked listë¼ë©´, ì‚½ì…ì€ ë¹¨ë¦¬ í•  ìˆ˜ ìˆìœ¼ë‚˜, Binary Searchë¥¼ í•˜ì§€ ëª»í•˜ì—¬ $O(n)$ì˜ ì‹œê°„ì´ ê±¸ë¦°ë‹¤.
  - Heaps: (weak invariant)
    - $t < \|k\|$ ì¸ì§€ ì²´í¬í•˜ê¸° ìœ„í•´ ëª¨ë“  ë…¸ë“œë¥¼ ì²´í¬í•´ì•¼ í•œë‹¤. $\rightarrow O(n)$ ì˜ ì‹œê°„ì´ ê±¸ë¦¼! 

ë§Œì•½, ì‚½ì…ì„ ë¹ ë¥´ê²Œ í•  ìˆ˜ ìˆë‹¤ë©´, sorted dataì—ì„œ í•´ê²° ê°€ëŠ¥í•¨ $\rightarrow$ BSTë¡œ í•´ê²°!

## BST (Binary Search Trees, ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬)

ë‹¤ìŒê³¼ ê°™ì´ ë” ì‘ì€ ê°’ì€ ì™¼ìª½, ë” í° ê°’ì€ ì˜¤ë¥¸ìª½ì— ë„£ëŠ”ë‹¤ëŠ” ê·œì¹™ì„ ë§Œë“¤ì–´ì§„ íŠ¸ë¦¬ë¥¼ BSTë¼ê³  í•œë‹¤.  



![image-20210414131601819](https://raw.githubusercontent.com/yongjulejule/yongjulejule.github.io/master/_posts/images/BST/algo-1%20(2).png)

__Structure__

>node x = key(x)
>
>pointers = parent(x), left(x) and right(x)

ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ ê° ë…¸ë“œëŠ” keyê°’ê³¼ ë¶€ëª¨ë…¸ë“œ, ìì‹ë…¸ë“œì˜ í¬ì¸í„°ë¥¼ ì €ì¥í•œ êµ¬ì¡°ì²´ë¡œ ì´ë£¨ì–´ì§„ë‹¤.

__Invariant(ë¶ˆë³€ì„±)__

> For any nodes x, if y is in the left subtree of x, key(y) â‰¤ key(x) and if y is in the right subtree, we have key(y) â‰¥ key(x) 

í•­ìƒ ì´ì™€ ê°™ì€ ê·œì¹™ì„ ë”°ë¼ì„œ ì €ì¥ì´ ë˜ì–´ í•­ìƒ ë¶€ëª¨ ë…¸ë“œì˜ ì™¼ìª½ subtreeëŠ” ë¶€ëª¨ ë…¸ë“œë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ê³ , ë¶€ëª¨ ë…¸ë“œì˜ ì˜¤ë¥¸ìª½ subtreeëŠ” ë¶€ëª¨ ë…¸ë“œë³´ë‹¤ í¬ê±°ë‚˜ ê°™ë‹¤ëŠ” ì„±ì§ˆì„ ì§€ë‹Œë‹¤.

__Operations__

- keyê°’ì„ ì •ë ¬ëœ ìˆœì„œë¡œ ì¶œë ¥

  - ë‹¨ìˆœí•œ ì¬ê·€ ì•Œê³ ë¦¬ì¦˜ì„ í†µí•´ ì‹¤í–‰í•  ìˆ˜ ìˆìœ¼ë©°, Inorder(ì¤‘ìœ„ ìˆœíšŒ) tree walkë¡œ êµ¬í˜„í•œë‹¤. 

  - ëª¨ë“  ë…¸ë“œë¥¼ ì§€ë‚˜ì•¼ í•˜ë¯€ë¡œ $O(n)$ ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ì§€ë‹˜.

  - Psuedo Code:

    ```c
    INORDER-TREE-WALK(x)
    if x != NIL
    	INORDER-TREE-WALK(x.left)
    print x.key
    INORDER-TREE-WALK(x.right)
    ```

- Minimun

  - x.leftê°€ NILì´ ë‚˜ì˜¬ ë•Œ ê¹Œì§€ leftë¡œ ì´ë™ í›„ keyê°’ì„ return.

- Mamximum

  - x.rightê°€ NILì´ ë‚˜ì˜¬ ë•Œ ê¹Œì§€ rightë¡œ ì´ë™ í›„ keyê°’ì„ return.

- Successor (í¬ê¸°ìˆœìœ¼ë¡œ ì •ë ¬í–ˆì„ë•Œ í˜„ì¬ keyê°’ ë‹¤ìŒ keyê°’)

  - x.rightê°€ ì¡´ì¬í•œë‹¤ë©´, x.rightë¶€í„° ì‹œì‘í•˜ì—¬ minimumì„ ì°¾ìœ¼ë©´ ë¨.

  - ê·¸ë ‡ì§€ ì•Šë‹¤ë©´, xì˜ successorë¥¼ y ë¼ í–ˆì„ ë•Œ, yëŠ” left childê°€ xì˜ ancestorì¸ ê°€ì¥ ì‘ì€ ancestorê°€ ë¨.

  - Psuedo Code:

    ```c
    TREE-SUCCESSOR(x)
    if x.right != NIL
        return TREE-MINIMUM(x.right)
    y = x.p
    while y != NIL and x == y.right
        x = y
    	y = y.p
    return y
    ```

- ProdecessorëŠ” Successorì™€ ë¹„ìŠ·í•œ ë°©ë²•ìœ¼ë¡œ í•˜ë©´ ë¨.

- Search

  - rootë…¸ë“œì™€ ì°¾ê³ ìí•˜ëŠ” key kê°€ ì£¼ì–´ì§€ë©´, key kê°€ ìˆëŠ” ë…¸ë“œì˜ ì£¼ì†Œë¥¼ ë°˜í™˜í•˜ê³  ì—†ìœ¼ë©´ NILë¥¼ ë°˜í™˜í•œë‹¤.

  - BSTê°€ ë§Œë“¤ì–´ì§„ ê·œì¹™ì— ë”°ë¼ ì°¾ì•„ê°€ë©´ ë¨.

  - Recursiveë¥¼ ì´ìš©í•œ Psuedo Code:

    ```c
    TREE-SEARCH(x,k) //recursive
    if x == NIL or k == x.key
    	return x
    if k < x.key
    	return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)
    ```

  - Iterativeë¥¼ ì´ìš©í•œ Psuedo Code:

    ```c
    ITERATIVE-TREE-SEARCH(x, k) //iterative
    while x != NIL and k != x.key
    	if k < x.key
    		x = x.left
    	else x = x.right
    return x
    ```

- Insertion

  - ì£¼ì–´ì§„ ê·œì¹™ì— ë”°ë¼ íŠ¸ë¦¬ë¥¼ íƒ€ê³  ë‚´ë ¤ê°€ë©´ì„œ, ì ì ˆí•œ ìœ„ì¹˜ì— ë„ë‹¬í•˜ë©´ ë„£ê³ ì í•˜ëŠ” ê°’ (z) ë¥¼ ì‚½ì…í•œë‹¤.

  - Pesudo Code

    ```c
    TREE-INSERT(T, z) //TëŠ” íŠ¸ë¦¬, zëŠ” ì‚½ì…í•˜ê³ ì í•˜ëŠ” ë°ì´í„°
    y = NIL
    x = T.root
    while x != NIL
    	y = x
    	if z.key < x.key
    		x = x.left
    	else x = x.right
    z.p = y //ëê¹Œì§€ ë‚´ë ¤ê°€ì„œ ë¶€ëª¨ë¥¼ ì„¤ì •
    if y == NIL
    	T.root = z // tree T was empty
    else if z.key < y.key
    	y.left = z
    else y.right = z //ì™¼ìª½/ì˜¤ë¥¸ìª½ ê²°ì •
    ```

- Deletion

  - ì‚­ì œ í›„ BSTì˜ êµ¬ì¡°ë¥¼ ìœ ì§€ì‹œì¼œì•¼ í•´ì„œ ë‹¤ë¥¸ ê³¼ì •ë³´ë‹¤ ë³µì¡í•˜ë‹¤.

  - zë¥¼ ì‚­ì œí•˜ê³ ì í•˜ëŠ” ë°ì´í„°ë¼ê³  í•˜ì

  - zì˜ ìì‹ ë…¸ë“œê°€ ì—†ë‹¤ë©´, zë¥¼ NILë¡œ ë§Œë“¤ì–´ì£¼ë©´ ëœë‹¤.

  - zê°€ í•˜ë‚˜ì˜ ìì‹ ë…¸ë“œë¥¼ ê°€ì§„ë‹¤ë©´, ìì‹ì´ zì˜ ìœ„ì¹˜ë¡œ ì˜¤ê³  ë¶€ëª¨ë…¸ë“œë¥¼ ì„¤ì •í•´ì£¼ë©´ ëœë‹¤.

  - zê°€ ë‘ ê°œì˜ ìì‹ ë…¸ë“œë¥¼ ê°€ì§„ë‹¤ë©´, zì˜ successorë¥¼ ì°¾ì•„ z ìë¦¬ë¡œ ì´ë™ì‹œí‚¤ê³ , ë¶€ëª¨ë…¸ë“œì™€ ìì‹ë…¸ë“œì˜ í¬ì¸í„°ë¥¼ ì¬ì„¤ì • í•´ì£¼ë©´ ëœë‹¤.

    ![2-children case](https://github.com/yongjulejule/yongjulejule.github.io/blob/master/_posts/images/BST/algo-1%20(3).png?raw=true)

  - Pesudo Code:

    ```c
    TRANSPLANT(T, u, v) //í¬ì¸í„°ë¥¼ ì¬ì„¤ì • í•´ì£¼ëŠ” ê³¼ì •
    if u.p == NIL
    	T.root = v
    else if u == u.p.left
    	u.p.left = v
    else u.p.right = v
    if v != NIL
    	v.p = u.p
    
    TREE-DELET(T, z) //ì‚­ì œ
    if z.left == NIL
    	TRANSPLANT(T, z, z.right)
    else if z.right == NIL
    	TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
    	if y.p != z
    		TRANSPLANT(T, y, y.right)
    		y.right = z.right
    		y.right.p = y
    TRANSPLANT(T, z, y)
    y.left = z.left
    y.left.p = y
    ```

- ì¶œë ¥ì„ ì œì™¸í•œ operationì€ ëª¨ë‘ $O(h)~ where ~ h = height$ ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ì§€ë‹Œë‹¤.

## Apply to Problem

ì£¼ì–´ì§„ ë¬¸ì œë¡œ ëŒì•„ì™€ì„œ, ë°ì´í„°ë¥¼ BSTë¡œ ë§Œë“¤ë©´ ë‹¤ìŒê³¼ ê°™ì•„ì§„ë‹¤.

![Figure 2](https://github.com/yongjulejule/yongjulejule.github.io/blob/master/_posts/images/BST/algo-1%20(4).png?raw=true)

ì‚½ì…ì„ í†µí•´ ìœ„ì™€ ê°™ì´ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìœ¼ë©° ìƒˆë¡œìš´ ë¹„í–‰ê¸° ì°©ë¥™ ì‹œê°„ì„ ì…ë ¥í•˜ê³ ì í•  ë•Œ, íƒìƒ‰ê³¼ ë™ì‹œì— $\le \|k\|$ ë¥¼ ì²´í¬í•˜ê³  ë°ì´í„°ë¥¼ ì‚½ì… í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ $O(h)$ ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ì§€ë‹Œë‹¤. ì´ë•Œ, $h$ëŠ” íŠ¸ë¦¬ì˜ ë†’ì´ ì´ë¯€ë¡œ, Balenced BSTì¸ ê²½ìš° $O(h)=O(lgn)$ ì´ ë˜ì–´ ë¬¸ì œë¥¼ í•´ê²° í•  ìˆ˜ ìˆë‹¤.

ë˜í•œ, ê°€ì¥ ë¹ ë¥¸ ì‹œê°„ì— ì°©ë¥™í•˜ëŠ” ë¹„í–‰ê¸°ëŠ” Minimumì„ ì´ìš©í•´ì„œ êµ¬í•  ìˆ˜ ìˆê³ , íŠ¹ì • ì°©ë¥™ ì‹œê°„ ë‹¤ìŒ ì°©ë¥™ ì‹œê°„ì€ Successorë¥¼ ì´ìš©í•˜ì—¬ êµ¬í•  ìˆ˜ ìˆë‹¤.

**í•˜ì§€ë§Œ ìµœì•…ì˜ ê²½ìš°, linked listì™€ í¬ê²Œ ë‹¤ë¥¼ ë°” ì—†ëŠ” Unbalanced BST ë§Œë“¤ì–´ì ¸ì„œ ì‹œê°„ë³µì¡ë„ê°€ ì»¤ì§€ëŠ” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤. $\rightarrow$ AVLì„ í†µí•´ í•´ê²°!**



## Code (C)

BSTì˜ í‹€ì„ ì‘ì„±í•œ ì½”ë“œì´ë‹¤. ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œë¥¼ ë¨¼ì € ì‘ì„±í–ˆìœ¼ë‚˜, BSTì˜ êµ¬ì¡°ë¥¼ ë³´ê¸°ì—ëŠ” í˜¼ë€ìŠ¤ëŸ¬ìš´ ì ì´ ìˆì–´ ë‹¤ì‹œ ì‘ì„±í•˜ì˜€ë‹¤. 

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef	struct	s_bst{
	int key;
	struct s_bst *parent;
	struct s_bst *left;
	struct s_bst *right;
}				t_bst;

t_bst	*search_node(t_bst *node, int key) //recursive search
{
	if (node == NULL || node->key == key)
		return (node);
	if (node->key > key)
		return search_node(node->left, key);
	else 
		return search_node(node->right, key);
}

t_bst	*minimum_node(t_bst *min)
{
	while (min->left != NULL)
		min = min->left;
	return (min);
}

void	modify_deleted_node(t_bst **bst, t_bst *replace_node, t_bst *newnode)
{
	if (replace_node->parent == NULL) //rootë…¸ë“œë¥¼ ì‚­ì œí•˜ë©´, ìƒˆë¡œìš´ ë…¸ë“œê°€ rootë…¸ë“œê°€ ëœë‹¤.
		*bst = newnode;
	else if (replace_node == replace_node->parent->left) //ì‚­ì œë  ë…¸ë“œì˜ ìì‹ ë…¸ë“œê°€ ì™¼ìª½ ìì‹ ë…¸ë“œë©´ ì™¼ìª½ì— update 
		replace_node->parent->left = newnode;
	else replace_node->parent->right = newnode; // ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œë©´ ì˜¤ë¥¸ìª½ì— update
	if (newnode != NULL) // ìì‹ ë…¸ë“œê°€ ì—†ë‹¤ë©´ ê·¸ëŒ€ë¡œ ì˜¬ë¦¼.
		newnode = replace_node;
}

void	delete_node(t_bst **bst, int key)
{
	t_bst *min;
	t_bst *delete_node;
	t_bst *tmp;

	delete_node = search_node(*bst, key);
	tmp = delete_node;
	if (delete_node == NULL)
		return ;
	if (delete_node->left == NULL) //leftê°€ NULLì´ë©´ rightê°€ newnodeë¡œ update
		modify_deleted_node(bst, delete_node, delete_node->right); 
	else if (delete_node->right == NULL) //rightê°€ NULLì´ë©´ leftê°€ newnodeë¡œ update
		modify_deleted_node(bst, delete_node, delete_node->left);
	else 
	{
		min = minimum_node(delete_node->right); //ì§€ìš¸ ë…¸ë“œì˜ successorë¥¼ ì°¾ì•„ì˜¨ë‹¤.
		if (min->parent != delete_node)
		{
			modify_deleted_node(bst, min, min->right); //minì´ ì‚­ì œëœ ë…¸ë“œ ìë¦¬ë¡œ ì˜¬ë¼ì˜¨ë‹¤.
			min->right = delete_node->right;
			min->right->parent = min;
		}
		modify_deleted_node(bst, delete_node, min);
		min->left = delete_node->left;
		min->left->parent = min;
	}
	free(tmp);
}

void	init_node(t_bst *newnode, int key)
{
	newnode->parent = NULL;
	newnode->left = NULL;
	newnode->right = NULL;
	newnode->key = key;
}

void	inorder_to_print(t_bst *bst)
{
	if (bst != NULL)
	{
		inorder_to_print(bst->left);
		printf("%d, ", bst->key);
		inorder_to_print(bst->right);
	}
}

void	insert_node(t_bst **root, int key)
{
	t_bst *y;
	t_bst *x;
	t_bst *newnode;

	newnode = (t_bst*)malloc(sizeof(t_bst));
	init_node(newnode, key);
	y = NULL;
	x = *root;
	while (x)
	{
		y = x;
		if (key < x->key)
			x = x->left;
		else x = x->right;
	}
	newnode->parent = y;
	if (y == NULL)
		*root = newnode;
	else if (newnode->key < y->key)
		y->left = newnode;
	else y->right = newnode;
}

void	postorder_to_free(t_bst *bst)
{
	if (bst != NULL)	
	{	
		postorder_to_free(bst->left);
		postorder_to_free(bst->right);
		free(bst);
	}
}

int main()
{
	t_bst **root;
	int i;
	int j = 0;

	root = (t_bst**)malloc(sizeof(t_bst*));
	*root = NULL;
	srand(42);
	while (j < 50) // 1 ~ 100 ê¹Œì§€ ìˆ˜ ì¤‘ì—ì„œ 50ê°œë¥¼ íŠ¸ë¦¬ì— ì‚½ì…
	{
		i = rand() % 100 + 1;
		insert_node(root, i);
		j++;
	}
	inorder_to_print(*root); //print í•˜ê¸° ìœ„í•œ ì¤‘ìœ„ ìˆœíšŒ
	printf("\n42ê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.\n");
	if (search_node(*root, 42))
		printf("ì¡´ì¬í•˜ëŠ” ë°ì´í„° ì…ë‹ˆë‹¤.\n");
	else printf("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë°ì´í„° ì…ë‹ˆë‹¤.\n");
	printf("41ì„ ì‚­ì œí•©ë‹ˆë‹¤.\n");
	delete_node(root, 41);
	inorder_to_print(*root);
	postorder_to_free(*root); //free í•˜ê¸° ìœ„í•œ í›„ìœ„ ìˆœíšŒ
	free(root);
	printf("\n");
}
```



ì£¼ì–´ì§„ ë¬¸ì œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‘ì„±í•œ ì½”ë“œì´ë‹¤. ê°œì¸ì  í¥ë¯¸ë¥¼ ìœ„í•´ ì‚¬ìš©í•œ ì“¸ë°ì—†ëŠ”(?) ëª…ë ¹ì–´ë“¤ì´ ë“±ì¥í•˜ê³  ì½”ë“œê°€ ë„ˆë¬´ ê¸¸ì–´ì¡Œì§€ë§Œ ì „ì²´ì ì¸ í‹€ì€ ìœ„ì˜ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ì—¬ ì‘ì„±í•˜ì˜€ë‹¤. Runaway Reservation Systemì„ ê¹”ë”í•˜ê²Œ êµ¬ì„±í•˜ê¸° ìœ„í•´ì„  `main`ì— ë¬´í•œë£¨í”„ì™€ switchë¬¸ì„ ì´ìš©í•˜ì—¬ ì‚­ì œ/ì‚½ì…/íƒìƒ‰/ì¶œë ¥ ê³¼ì •ì„ ë„£ê³ , `read` ëŒ€ì‹  `fgets` ê°™ì€ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ê¹”ë”í•˜ê²Œ ì‘ë™í•  ê²ƒì´ë¼ ìƒê°í•œë‹¤.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define K 3
#define ABS(x) ((x < 0) ? (-x) : (x))

typedef	struct	s_bst{
	int key;
	struct s_bst *parent;
	struct s_bst *left;
	struct s_bst *right;
}				t_bst;

t_bst	*search_node_to_delete(t_bst *node, int key) //recursive search
{
	if (node == NULL || node->key == key)
		return (node);
	if (node->key > key)
		return search_node_to_delete(node->left, key);
	else 
		return search_node_to_delete(node->right, key);
}

t_bst	*minimum_node(t_bst *min)
{
	while (min->left != NULL)
		min = min->left;
	return (min);
}

void	modify_deleted_node(t_bst **bst, t_bst *replace_node, t_bst *newnode)
{
	if (replace_node->parent == NULL) //rootë…¸ë“œë¥¼ ì‚­ì œí•˜ë©´, ìƒˆë¡œìš´ ë…¸ë“œê°€ rootë…¸ë“œê°€ ëœë‹¤.
		*bst = newnode;
	else if (replace_node == replace_node->parent->left) //ì‚­ì œë  ë…¸ë“œì˜ ìì‹ ë…¸ë“œê°€ ì™¼ìª½ ìì‹ ë…¸ë“œë©´ ì™¼ìª½ì— update 
		replace_node->parent->left = newnode;
	else replace_node->parent->right = newnode; // ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œë©´ ì˜¤ë¥¸ìª½ì— update
	if (newnode != NULL) // ìì‹ ë…¸ë“œê°€ ì—†ë‹¤ë©´ ê·¸ëŒ€ë¡œ ì˜¬ë¦¼.
		newnode = replace_node;
}

void	delete_node(t_bst **bst, int key)
{
	t_bst *min;
	t_bst *delete_node;
	t_bst *tmp;

	delete_node = search_node_to_delete(*bst, key);
	tmp = delete_node;
	if (delete_node == NULL)
		return ;
	if (delete_node->left == NULL) //leftê°€ NULLì´ë©´ rightê°€ newnodeë¡œ update
		modify_deleted_node(bst, delete_node, delete_node->right); 
	else if (delete_node->right == NULL) //rightê°€ NULLì´ë©´ leftê°€ newnodeë¡œ update
		modify_deleted_node(bst, delete_node, delete_node->left);
	else 
	{
		min = minimum_node(delete_node->right); //ì§€ìš¸ ë…¸ë“œì˜ successorë¥¼ ì°¾ì•„ì˜¨ë‹¤.
		if (min->parent != delete_node)
		{
			modify_deleted_node(bst, min, min->right); //minì´ ì‚­ì œëœ ë…¸ë“œ ìë¦¬ë¡œ ì˜¬ë¼ì˜¨ë‹¤.
			min->right = delete_node->right;
			min->right->parent = min;
		}
		modify_deleted_node(bst, delete_node, min);
		min->left = delete_node->left;
		min->left->parent = min;
	}
	free(tmp);
}

void	init_node(t_bst *newnode, int key)
{
	newnode->parent = NULL;
	newnode->left = NULL;
	newnode->right = NULL;
	newnode->key = key;
}

int		search_node(t_bst *node, int key) //iterative search, Kì¡°ê±´ì„ ìœ„í•´ ìˆ˜ì •í•œ í•¨ìˆ˜
{
	while (node != NULL && (ABS((key - (node->key))) >= K)) // Kë¶„ ì•ˆì— ì°©ë¥™ì„ í•  ìˆ˜ ì—†ìŒ.
	{
		if (key < node->key)
			node = node->left;
		else 
			node = node->right;
	}
	return ((node == NULL) ? 1 : 0);
}

void	inorder_tree_walk(t_bst *bst)
{
	if (bst != NULL)
	{
		inorder_tree_walk(bst->left);
		printf("%d, ", bst->key);
		inorder_tree_walk(bst->right);
	}
}

void	insert_node(t_bst **root, int key)
{
	t_bst *y;
	t_bst *x;
	t_bst *newnode;

	newnode = (t_bst*)malloc(sizeof(t_bst));
	init_node(newnode, key);
	y = NULL;
	x = *root;
	while (x)
	{
		y = x;
		if (key < x->key)
			x = x->left;
		else x = x->right;
	}
	newnode->parent = y;
	if (y == NULL)
		*root = newnode;
	else if (newnode->key < y->key)
		y->left = newnode;
	else y->right = newnode;
}

void	postorder_tree_walk(t_bst *bst)
{
	if (bst != NULL)	
	{	
		postorder_tree_walk(bst->left);
		postorder_tree_walk(bst->right);
		free(bst);
	}
}

int main()
{
	t_bst **root;
	int R[] = {46, 41, 49, 37, 56};
	int i;
	char buf[6] = "";

	i = 0;
	root = (t_bst**)malloc(sizeof(t_bst*));
	*root = NULL;
	while (i < 5)
	{
		insert_node(root, R[i]);
		i++;
	}
	inorder_tree_walk(*root); //print í•˜ê¸° ìœ„í•œ ì¤‘ìœ„ ìˆœíšŒ
	printf("ì°©ë¥™ ì˜ˆì • ì‹œê°„ì„ ì…ë ¥í•˜ì‹œì˜¤(2ìë¦¬ ì •ìˆ˜)\n");
	read(0, buf, 2);
	i = atoi(buf);
	if (!search_node(*root, i))
		printf("í•´ë‹¹ ì‹œê°„ì—” ì°©ë¥™ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n");
	else
	{
		insert_node(root, i);
		printf("ìš”ì²­í•œ ì‹œê°„ì— ì˜ˆì•½ë˜ì—ˆìŠµë‹ˆë‹¤.\n");
	}
	printf("ì·¨ì†Œí•  ì‹œê°„ì„ ì…ë ¥í•˜ì„¸ìš”");
	inorder_tree_walk(*root);

	read(0, buf, 2);
	i = atoi(buf);
	delete_node(root, i);
	printf("ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.");
	inorder_tree_walk(*root);
	postorder_tree_walk(*root); //free í•˜ê¸° ìœ„í•œ í›„ìœ„ ìˆœíšŒ
	free(root);
}
```

## ì‚½ì§ˆğŸ¤¦

ì—°ê²° ë¦¬ìŠ¤íŠ¸ë„ ì œëŒ€ë¡œ êµ¬í˜„ í•´ ë³¸ì ì´ ì—†ëŠ”ë°, êµ¬ì¡°ì²´ë¡œ íŠ¸ë¦¬ë¥¼ êµ¬í˜„í•˜ë ¤ë‹ˆ ìƒê°ë³´ë‹¤ ê³ ë ¤í• ê²Œ ë§ì•˜ë‹¤. ì‚½ì… ê³¼ì •ì—ì„œ root ë…¸ë“œë¥¼ ê°™ì´ ë§Œë“¤ë‹¤ ë³´ë‹ˆ ì§€ì—­ë³€ìˆ˜ì—ì„œ ë§Œë“  ê°’ì´ ë‚ ì•„ê°€ ë²„ë ¤ì„œ ì²˜ìŒì—” rootë…¸ë“œë¥¼ ê³„ì† return í•´ì¤¬ìœ¼ë‚˜, ë§¤ë²ˆ ê°’ì„ return í•˜ëŠ” ì ì´ ë§˜ì— ì•ˆë“¤ì–´ì„œ ì´ì¤‘ í¬ì¸í„°ë¥¼ ì“°ëŠ” ë°©ì‹ìœ¼ë¡œ í•´ê²°í•˜ì˜€ë‹¤.  

ë˜í•œ ë¨¸ë¦¿ì†ìœ¼ë¡œ ê·¸ë ¤ë³¼ë•ŒëŠ” ìƒê°í•˜ì§€ ëª»í–ˆë˜ ë©”ëª¨ë¦¬ ë¬¸ì œì— ë°œëª©ì„ ì¡í˜”ë‹¤. ë§¤ë²ˆ ë™ì  í• ë‹¹ì„ í†µí•˜ì—¬ ë…¸ë“œë¥¼ ë§Œë“¤ì–´ ì¤˜ì„œ ëë‚˜ê³  freeë¥¼ í•´ì¤„ ë•Œ ë†“ì¹˜ì§€ ì•Šê¸° ìœ„í•´ì„œ ì‹ ê²½ì¨ì•¼ í–ˆë‹¤. í›„ìœ„ ìˆœíšŒë¥¼ ì´ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•˜ì˜€ìœ¼ë©°, ì „ìœ„(preorder) / ì¤‘ìœ„(inorder) / í›„ìœ„(postorder) ìˆœíšŒë¥¼ ì´ë¡ ë§Œ ì•Œê³  ìˆì—ˆëŠ”ë° ì²˜ìŒìœ¼ë¡œ êµ¬í˜„í•´ ë³´ì•˜ë‹¤.

Deleteí•œ ë°ì´í„° ì—­ì‹œ freeë¥¼ í•´ì¤˜ì•¼ í•˜ëŠ”ë°, ê° ê²½ìš°ì— ë”°ë¼ ë…¸ë“œê°€ ì‚¬ë¼ì§€ëŠ” ìœ„ì¹˜ê°€ ë‹¬ë¼ì ¸ì„œ ì–´ë–»ê²Œ freeë¥¼ í•´ì¤˜ì•¼ í• ì§€ ë¬´ì²™ ë‚œê°í–ˆë‹¤. í•˜ì§€ë§Œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ í• ë‹¹ëœ ë©”ëª¨ë¦¬ë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ ìƒì—ˆì„ë•Œ ë³µêµ¬í•  ë°©ë²•ì´ ì—†ëŠ”ê²Œ ë¬¸ì œë¼ëŠ” ì ì— ì°©ì•ˆí•˜ì—¬ `t_bst *tmp` ë¥¼ ì„ ì–¸í•˜ì—¬ ì‚­ì œí•  ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ê²Œ í•˜ê³ , ë§ˆì§€ë§‰ì— `free(tmp)` ë¥¼ í•˜ì—¬ í•´ê²°í•˜ì˜€ë‹¤. ì´ ì•„ì´ë””ì–´ëŠ” ë‚˜ì¤‘ì— ì¨ë¨¹ì„ ìˆ˜ ë„ ìˆì„ê²ƒ ê°™ë‹¤...!

Cì–¸ì–´ì—ì„œ NILì´ ì—†ì–´ì„œ NULLë¡œ ì²˜ë¦¬í–ˆìœ¼ë‚˜, NULLì¸ ë…¸ë“œì˜ keyê°’ì„ ì–´ë–»ê²Œ ì •í• ì§€ ë¼ëŠ” ì˜ë¬¸ì´ ìƒê²¼ë‹¤. ë‹¨ìˆœíˆ NULLì¸ ë…¸ë“œì˜ keyê°’ì„ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ í•´ê²°ë  ë¬¸ì œì´ì§€ë§Œ, NILì„ ì •ì˜í•´ì„œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì´ ë” ë‚˜ì•˜ì„ê²ƒ ê°™ë‹¤.

ë§¤í¬ë¡œ í™œìš©ì— ìˆì–´ì„œë„ ë¬¸ì œê°€ ë°œìƒí•˜ì˜€ëŠ”ë°, `ABS(key - (node->key))` ì´ë ‡ê²Œ ì‚¬ìš©í•˜ë‹ˆê¹Œ ë§¤í¬ë¡œê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ì§€ ì•Šì•˜ë‹¤. `-key - (node->key)` ë¥¼ ê³„ì‚°í•œ ê²°ê³¼ê°€ ë‚˜ì™”ëŠ”ë°, êµ¬ê¸€ë§ í•´ë³´ë‹ˆ ë§¤í¬ë¡œ í•¨ìˆ˜ëŠ” ì—°ì‚° ìˆœì„œê°€ ê¼¬ì´ëŠ” ê²½ìš°ê°€ ë§ì•„ ì˜ ì¡ì•„ì¤˜ì•¼ í•˜ë©° ê° ì¸ìì—ë„ ê´„í˜¸ë¥¼ ì”Œì›Œì£¼ëŠ”ê²Œ ì¢‹ë‹¤ê³  í•œë‹¤. (e.g. `a*b`ë¥¼ ë§¤í¬ë¡œë¡œ ì •ì˜í•˜ê³  `a+1, b+1`ë¥¼ ëŒ€ì…í•˜ëŠ” ê²½ìš°) ê·¸ë˜ì„œ ì‘ì„±í•œ ë§¤í¬ë¡œë¥¼ í’€ì–´ì„œ ì¨ë³´ë‹ˆ, `ABS(key - (node->key))`ëŠ” `((key - (node->key)<0) ? (-key -(node->key)) : (key - node->key))` ê°€ ë˜ì–´ ê¼¬ì´ê²Œ ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆì—ˆë‹¤.

ì‹¬ì‹¬í•´ì„œ í‘œì¤€ì…ë ¥ì„ `read` í•¨ìˆ˜ë¡œ ì½ì–´ì™”ëŠ”ë°, ì—¬ê¸°ì„œë„ ì˜ì™¸ì˜ ë¬¸ì œê°€ ë°œìƒí•˜ì˜€ë‹¤. 2ë°”ì´íŠ¸ë§Œ ì½ìœ¼ë ¤ëŠ” ëª©ì ìœ¼ë¡œ  `char buf[3] = ""` ìœ¼ë¡œ ì„ ì–¸í•˜ì˜€ëŠ”ë°, ê°™ì€ ë²„í¼ì— `read`ë¥¼ ë‘ë²ˆ í•˜ë‹ˆ ì´ë¯¸ ì´ì „ì— ì½ì—ˆë˜ ë°ì´í„°ê°€ ë‚¨ì•„ìˆë˜ ìƒíƒœì—ì„œ ì½ì–´ì˜¤ë©´ì„œ Segmentation faultê°€ ë°œìƒí•˜ì˜€ë‹¤. lldbë¥¼ ì´ìš©í•´ ì—´ì‹¬íˆ ë””ë²„ê¹…ì„ í•´ë³´ë‹ˆ, ì´ì „ ì…ë ¥ì—ì„œ EOFë¡œ ì…ë ¥ì„ ì¢…ë£Œí•˜ì§€ ì•Šì•„ ìƒê¸°ëŠ” ë¬¸ì œì˜€ìœ¼ë©° `ctrl+d` ë¥¼ ì´ìš©í•˜ì—¬ ì…ë ¥í•˜ë‹ˆ í•´ê²°ì´ ë˜ê¸´ ë˜ì—ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ë²ˆì—” `printf`í•¨ìˆ˜ì˜ ì‹¤í–‰ ìˆœì„œê°€ ê¼¬ì´ëŠ” ì´ìƒí•œ ë²„ê·¸ê°€ ë°œìƒí•˜ì˜€ë‹¤. ë””ë²„ê¹…ì´ í˜ë“¤ì–´ì„œ(ê·€ì°®... ã…) ì´ê±´ ë” ê³µë¶€ë¥¼ í•´ë´ì•¼ ê² ë‹¤.

## ì°¸ì¡°

_[MIT OCW 6.006 Introducion to Algorithms ê°•ì˜ ìë£Œ ë° ê°•ì˜ ë‚´ìš©](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/)_

_Introduce to Algorithms, 3rd Edition_